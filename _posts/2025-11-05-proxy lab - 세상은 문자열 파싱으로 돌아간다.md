---
layout: post
title: proxy lab - 세상은 문자열 파싱으로 돌아간다
date: 2025-11-05 15:06:00
description:
tags: 
categories: 크래프톤 정글
---

## 세상은 문자열 파싱으로 돌아간다.

이번 proxy lab을 하며 가장 크게 느낀 부분이 이 제목이다.
평소 인터넷을 접속할 때나 spring, node등을 사용하여 웹 서버를 열었을 때 어떻게 통신을 했는지 관심을 크게 가지지 않았다. 그저 주고 받고 하는거구나 하고 생각을 했다.
이번에 proxy lab을 통해 직접 소켓 통신을 구현하면서 어떤걸 주고 받는지 모든걸 명시하는 것이 신기했다. 무슨 통신을 하는지, 무슨 버전인지, 등등 많은 정보들이 헤더에 담겨가고 그것을 받는 쪽도 일일이 헤더를 파싱하며 데이터를 읽는다.  
이번에는 proxy lab을 하며 느낀 부분들을 적어보려한다.

## 소켓도 파일이에요

소켓은 프로세스 간 네트워크 I/O 엔드 포인트이다. 네트워크 통신의 양 끝단에 있는 것이 소켓이다.
프로세스 간 통신을 파일 I/O처럼 단일 인터페이스로 추상화 한것이 소켓의 시작이다. 그 덕분에 우리는 소켓을 open, write, read와 같은 I/O작업 처럼 사용할 수 있다.
이번 소켓 연결을 하면서 가장 신기한건 우리가 디스크를 읽는거와 소켓 통신을 하는게 차이가 없다는 것이다. 이것이 추상화의 힘인가 싶다.

{% include figure.liquid path="/assets/img/blog/file-meme.png" class="w-50" caption="결국은 다 파일이었어…!" %}

```c
connfd = Accept(proxyfd, NULL, NULL);
```

소켓 통신을 보면 파일 디스크럽터를 통해 입력을 받고 통신 또한 파일 디스크럽터를 통해 하는걸 볼 수 있다! 결국 모든게 다 파일인 것이다!  
이러한 소켓 통신을 기반으로 우리가 아는 웹 HTTP는 어떻게 통신하는지 알아보자

## HTTP와 문자열 파싱

대부분의 통신은 소켓을 통해 이루어 진다. 그러면 HTTP통신은 어떻게 이루어지는지 알아보자! TCP같은 통신 규격도 있지만 나는 재밌게 보았던 문자열 파싱 중심으로 말해보려한다.

우리가 naver같은 서버를 접속하면 어떤 원리로 사이트를 띄워줄까? 그것은 HTTP규격에 따라 통신을 하기에 가능한일이다.

```c
GET / HTTP/1.0
<header...>
```

우리가 HTTP요청을 보내면 서버는 위와같은 헤더를 받게된다.
GET요청으로 `/` 이라는 데이터를 요구한다! HTTP통신 버전은 1.0이라는 소리이다.
그러면 이 요청에따라 서버는 응답하면 되는 것이다. 컴퓨터가 이러한 글을 읽을 수 있는 이유는 하나하나 파싱을 하기 때문이다.

<div class="img-pair">
  <figure class="img-pair__item">
    <img src="{{ '/assets/img/blog/chrom-parse.png' | relative_url }}" alt="크로니움 파싱 코드">
    <figcaption class="img-pair__caption">크로니움 파싱 코드</figcaption>
  </figure>
  <figure class="img-pair__item">
    <img src="{{ '/assets/img/blog/tomcat-parse.png' | relative_url }}" alt="톰켓 서버 파싱 코드">
    <figcaption class="img-pair__caption">톰켓 서버 파싱 코드</figcaption>
  </figure>
</div>

크로니움, 톰켓 서버 코드에도 문자열을 파싱하는 코드가 있는걸 볼 수 있다.  
이렇게 헤더를 파싱하면 이후 작업은 간단하다 분기처리를 통해 클라이언트가 원하는 걸 주면된다
GET일때는 어떤걸 줄지, POST일때는, `/` 로 들어오면,  `/abc.png` 같은 파일을 요청하면, 아니면 어떠한 실행파일의 결과를 요청하면! 이런걸 처리하여 클라이언트에게 주는 것이다.

## 컴퓨터는 글을 읽을 줄 모른다.

위에서 말했든 나는 다른 웹 프레임워크를 쓰며 어떻게 주소가 매핑되는지 관심이 없었다.
자석처럼 알아서 잘 매핑되는구나 생각했다. 하지만 직접 구현을 해보니 잘못된 생각이였음을 깨닳았다.

결국 컴퓨터는 글을 읽을 줄 모르고 소켓으로 온 내용이 요청인지 아닌지도 구분하지 못한다. 우리가 통신을 하기 위해 규격을 세우고 그 내용대로 통신을 하기에 가능한 것이다.
규격대로 요청을 하고 규격대로 하나하나 파싱하고 분기 처리하여 결과를 돌려준다. 내부적인 코드를 보니 참 컴퓨터스럽다는 생각을 했다.
