<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://jeongns.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://jeongns.github.io/" rel="alternate" type="text/html" hreflang="ko"/><updated>2026-01-28T14:40:01+00:00</updated><id>https://jeongns.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">크래프톤 정글 나만무 회고</title><link href="https://jeongns.github.io/blog/2026/%ED%81%AC%EB%9E%98%ED%94%84%ED%86%A4-%EC%A0%95%EA%B8%80-%EB%82%98%EB%A7%8C%EB%AC%B4-%ED%9A%8C%EA%B3%A0/" rel="alternate" type="text/html" title="크래프톤 정글 나만무 회고"/><published>2026-01-28T01:08:00+00:00</published><updated>2026-01-28T01:08:00+00:00</updated><id>https://jeongns.github.io/blog/2026/%ED%81%AC%EB%9E%98%ED%94%84%ED%86%A4%20%EC%A0%95%EA%B8%80%20%EB%82%98%EB%A7%8C%EB%AC%B4%20%ED%9A%8C%EA%B3%A0</id><content type="html" xml:base="https://jeongns.github.io/blog/2026/%ED%81%AC%EB%9E%98%ED%94%84%ED%86%A4-%EC%A0%95%EA%B8%80-%EB%82%98%EB%A7%8C%EB%AC%B4-%ED%9A%8C%EA%B3%A0/"><![CDATA[<p>크래프톤 정글의 마지막 프로젝트 기간인 나만무가 끝났다. 5주간 달려온 나의 경험을 간단하게 적어보려한다.</p> <h2 id="팀장을-왜-했나">팀장을 왜 했나</h2> <p>정글에 온김에 모든걸 해보고 싶다는 생각이 들었고 이어서 나만무 팀장도 맡아보고 싶다는 생각이 들었다.<br/> 팀장과 같은 리더 역할을 경험한 적은 없지만 팀장을 하게되면 더 열심히 하지 않을까? 라는 생각에 팀장을 지원하게 되었다.</p> <h2 id="팀장은-어떤-역할일까">팀장은 어떤 역할일까</h2> <p>처음에 시작할때는 위와같이 단순히 내가 더 열심히 하기 위해서 팀장을 지원했지만 막상 해보니 팀장은 생각보다 많은 역할을 해야했다. 우리 팀의 최종 선택은 항상 팀장의 몫이였기 때문에 생각을 해야 하는게 많았다.</p> <ul> <li>기획 결정</li> <li>업무 분배</li> <li>일정 관리</li> <li>프로젝트 초기 설계 등등….</li> </ul> <p>나는 단순히 팀장이 되면 코드를 더 열심히 짤줄 알았지만 오히려 코드를 짤 시간이 더 줄어들었다. ㅋㅋ<br/> 물론 그래서 후회하지는 않는다. 그만큼 코드 외적으로 팀장으로서 경험을 많이 했기 때문이다.</p> <h2 id="아쉬운-점">아쉬운 점</h2> <p>우리 팀원들이 잘해주어서 우리 프로젝트나 코드나 아쉬운점 보다 내가 팀장으로서 아쉬운 점이 많았다.<br/> 그중 가장 아쉬운건 업무 분배를 체계적으로 못한 것이다.</p> <p>팀원들끼리 친하다 보니 업무 분배를 그때그때 구두로 맡아 진행하는 경우가 많았다.<br/> 내가 업무를 주는게 아닌 팀원들이 스스로 업무를 찾아서 맡는 방식이였다.<br/> 그렇다 보니 조금 업무 분배가 고르지 않았던 것 같고 스스로 업무를 찾지 않는 팀원 같은 경우 업무가 없는 상황이 발생하기도 했다.</p> <p>협업을 위한 툴이나 업무를 조금 더 체계화 해서 팀원들에게 역할을 잘 주었더라면 조금 좋았을 것 같다.<br/> 처음 팀장으로서 아쉬운점도 많지만 그만큼 반성하고 배울 점도 많았다.</p> <h2 id="칭찬할-점">칭찬할 점</h2> <p>팀장으로서 잘한 부분이라 생각드든 점은 초기 프로젝트 프레임워크 설계는 잘한 것 같다.<br/> 프로젝트 시작 시 프레임워크가 정해지지 않으면 붕 뜨는 시간이 길어질 것 같아 프로젝트 시작 전에 미리 프레임워크를 설계하고 팀원들과 공유했다.<br/> 덕분에 프로젝트 시작하자마자 바로 코드를 짜는데 집중 할 수 있었다. 이부분은 팀장으로서 잘한 부분 같다!</p> <h2 id="마무리">마무리</h2> <p>무엇보다 팀원들에게 감사함을 전하고 싶다.<br/> 어리숙하고 어린 팀장이지만 잘 따라와주고 적극적으로 참여해주어서 나만무를 성공적으로 끝낼 수 있었던 것 같다.</p> <p><a href="https://www.youtube.com/watch?v=WQJ41tTqtSc">나만무 발표 영상</a><br/> <a href="https://github.com/star-ter/star-ter">나만무 결과 GIT</a></p>]]></content><author><name></name></author><category term="크래프톤"/><category term="정글"/><category term="나만무"/><summary type="html"><![CDATA[크래프톤 정글의 마지막 프로젝트 기간인 나만무가 끝났다. 5주간 달려온 나의 경험을 간단하게 적어보려한다.]]></summary></entry><entry><title type="html">Pintos - fd table 구조 고르기</title><link href="https://jeongns.github.io/blog/2025/Pintos-fd-table-%EA%B5%AC%EC%A1%B0-%EA%B3%A0%EB%A5%B4%EA%B8%B0/" rel="alternate" type="text/html" title="Pintos - fd table 구조 고르기"/><published>2025-11-21T01:08:00+00:00</published><updated>2025-11-21T01:08:00+00:00</updated><id>https://jeongns.github.io/blog/2025/Pintos%20-%20fd%20table%20%EA%B5%AC%EC%A1%B0%20%EA%B3%A0%EB%A5%B4%EA%B8%B0</id><content type="html" xml:base="https://jeongns.github.io/blog/2025/Pintos-fd-table-%EA%B5%AC%EC%A1%B0-%EA%B3%A0%EB%A5%B4%EA%B8%B0/"><![CDATA[<h2 id="fd-table-뭐가-좋을까">fd table 뭐가 좋을까?</h2> <p>fd table은 ADT처럼 내부 구현은 상관없이 <code class="language-plaintext highlighter-rouge">fd → file</code> 매핑만 잘되면 상관없다. 그렇다 보니 사람들마다 짜는 방식이 다를 수 있고 실제로 우리 조원 세명 모두 조금씩 다른 fd table을 구현했다.<br/> 조원들의 fd table을 보며 무엇이 좋은 방법일까 더 좋은 방법은 없을까 고민한 이야기를 해보겠다.</p> <h2 id="조원들의-구조">조원들의 구조</h2> <p>조원들이 짠 구조를 A, B, C라고 칭하겠다. file의 구조체는 <code class="language-plaintext highlighter-rouge">struct file</code> 이다. fd table이 동적 확장이 가능한 구조로 구현을 하였다. 대표적으로 아래 세개 함수를 중심으로 설명 하겠다.</p> <ul> <li><code class="language-plaintext highlighter-rouge">fd_allocate()</code>: file를 받아 fd table에 넣고 넣은 위치를 반환하는 함수</li> <li><code class="language-plaintext highlighter-rouge">fd_close()</code>: fd를 받아 해당 fd를 비우는 함수</li> <li><code class="language-plaintext highlighter-rouge">fd_expand()</code>: fd table 크기가 부족할 경우 확장하는 함수</li> </ul> <h3 id="a-구조">A 구조</h3> <p>매우 평범한 구조이다. file배열 <code class="language-plaintext highlighter-rouge">struct file**</code> 과 관리를 위한 <code class="language-plaintext highlighter-rouge">table_size</code> 를 가진다. <code class="language-plaintext highlighter-rouge">fd_allocate()</code> 를 할 경우 2부터(stdin, stdout을 제외한) <code class="language-plaintext highlighter-rouge">table_size</code> 순회를 하며 비어있는 fd를 찾는다. 찾을 경우 fd를 할당하고 해당 fd를 return하고 찾지 못할 경우, 즉 크기가 부족한 경우 크기를 늘려 위 과정을 다시 시도한다.</p> <p><code class="language-plaintext highlighter-rouge">fd_expand()</code> 같은 경우 현재보다 큰 파일 테이블을 만들고 복사하는 형식으로 관리한다.</p> <h3 id="b-구조">B 구조</h3> <p>A구조에 <code class="language-plaintext highlighter-rouge">fd_next</code> 라는 다음 파일이 등록될 번호를 저장하는 변수를 사용하는 구조이다. <code class="language-plaintext highlighter-rouge">fd_allocate()</code> 시 <code class="language-plaintext highlighter-rouge">fd_next</code> 를 이용해 바로 할당하고 <code class="language-plaintext highlighter-rouge">fd_next</code> 부터 <code class="language-plaintext highlighter-rouge">table_size</code> 까지 순회하며 다음 <code class="language-plaintext highlighter-rouge">fd_next</code> 를 찾는다. 찾지 못할 경우 A구조와 동일하게 확장을 한 후 다시 시도한다.</p> <p><code class="language-plaintext highlighter-rouge">fd_close()</code> 를 하는 위치가 <code class="language-plaintext highlighter-rouge">fd_next</code> 보다 작을 경우 <code class="language-plaintext highlighter-rouge">fd_next</code> 를 업데이트 해준다.</p> <p>확장하는 방식은 A구조와 동일하다.</p> <h3 id="c-구조">C 구조</h3> <p>B구조와 같이 <code class="language-plaintext highlighter-rouge">fd_next</code> 를 가지지만 특이한 점이 배열들을 기차처럼 이어 붙히는 형식이다. <code class="language-plaintext highlighter-rouge">[64] - [64] - [64]</code> 링크드 리스트로 배열들을 묶어서 확장을 할때 복사 붙혀넣기 하는 과정없이 할당만으로 확장을 하는 방식이다. 순회 하는방식이 링크드 리스트이기 때문에 A, B구조와 조금 다르다.</p> <h2 id="무슨-구조가-좋을까">무슨 구조가 좋을까?</h2> <p>A, B, C 구조 중에 뭐가 제일 좋을까? A구조 보다는 B구조가 더 좋다고 생각한다. <code class="language-plaintext highlighter-rouge">fd_next</code> 를 추가하는 것으로 보편적인 탐색 범위를 많이 줄일 수 있다. C구조같은 경우 확장을 복사 없이하여 좋아 보였지만 순회 하는 방식이 복잡하다는 생각이 들었다.<br/> 조원들끼리 얘기를 하다가 저번 주 주간 발표 때 들었던 비트맵이 떠올랐다. 비트맵으로 fd table을 관리하면 좋을 것 같다는 생각이 들었다.</p> <h2 id="비트맵을-이용한-fd-table">비트맵을 이용한 fd table</h2> <p>fd table 중에 할당이 안된 가장 작은 fd를 구하는데에는 비트맵 만한게 없다고 생각했다. B구조에서 비트맵 방식을 더하는 방식으로 설계하니. 이를 통해 <code class="language-plaintext highlighter-rouge">fd_next</code> 를 연산 비용을 대폭 줄일 수 있었다.</p> <p>long타입 배열을 비트맵으로 활용하여 한번에 64개의 fd를 탐색할 수 있었다. 순회 시 64개 단위로 탐색하며 비어있는 fd를 빠르게 찾는 방식이다. 기존이라면 100개의 fd를 탐색할 때 100번 순회를 해야했지만 비트맵을 이용하면 최대 2번의 순회로 끝낼 수 있다.</p> <p>찾아보니 리눅스도 비트맵 방식을 사용하고 있어 뭔가 기분이 좋았다 ㅋㅋ</p> <h2 id="코드는-두드릴수록-단단해진다">코드는 두드릴수록 단단해진다</h2> <p>코드는 두드릴수록 단단해지는 것 같다. 이번에는 구조가 다 달라 서로의 생각이 많이 부딪쳤고 이 과정에서 더 좋은 코드가 나오는 것을 체감했다. pintos 과제는 같은 과제를 구현하고 merge를 해야해서 서로의 코드 중 하나를 고르는 곤란한 상황도 많이 나오지만 그런 과정 속에서 단단한 코드를 찾는 것이 pintos주차 중에 가장 중요한 것 이라 생각한다.</p>]]></content><author><name></name></author><category term="크래프톤"/><category term="정글"/><category term="Pintos"/><summary type="html"><![CDATA[fd table 뭐가 좋을까?]]></summary></entry><entry><title type="html">proxy lab - 세상은 문자열 파싱으로 돌아간다</title><link href="https://jeongns.github.io/blog/2025/proxy-lab-%EC%84%B8%EC%83%81%EC%9D%80-%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%8C%8C%EC%8B%B1%EC%9C%BC%EB%A1%9C-%EB%8F%8C%EC%95%84%EA%B0%84%EB%8B%A4/" rel="alternate" type="text/html" title="proxy lab - 세상은 문자열 파싱으로 돌아간다"/><published>2025-11-05T15:06:00+00:00</published><updated>2025-11-05T15:06:00+00:00</updated><id>https://jeongns.github.io/blog/2025/proxy%20lab%20-%20%EC%84%B8%EC%83%81%EC%9D%80%20%EB%AC%B8%EC%9E%90%EC%97%B4%20%ED%8C%8C%EC%8B%B1%EC%9C%BC%EB%A1%9C%20%EB%8F%8C%EC%95%84%EA%B0%84%EB%8B%A4</id><content type="html" xml:base="https://jeongns.github.io/blog/2025/proxy-lab-%EC%84%B8%EC%83%81%EC%9D%80-%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%8C%8C%EC%8B%B1%EC%9C%BC%EB%A1%9C-%EB%8F%8C%EC%95%84%EA%B0%84%EB%8B%A4/"><![CDATA[<h2 id="세상은-문자열-파싱으로-돌아간다">세상은 문자열 파싱으로 돌아간다.</h2> <p>이번 proxy lab을 하며 가장 크게 느낀 부분이 이 제목이다. 평소 인터넷을 접속할 때나 spring, node등을 사용하여 웹 서버를 열었을 때 어떻게 통신을 했는지 관심을 크게 가지지 않았다. 그저 주고 받고 하는거구나 하고 생각을 했다. 이번에 proxy lab을 통해 직접 소켓 통신을 구현하면서 어떤걸 주고 받는지 모든걸 명시하는 것이 신기했다. 무슨 통신을 하는지, 무슨 버전인지, 등등 많은 정보들이 헤더에 담겨가고 그것을 받는 쪽도 일일이 헤더를 파싱하며 데이터를 읽는다.<br/> 이번에는 proxy lab을 하며 느낀 부분들을 적어보려한다.</p> <h2 id="소켓도-파일이에요">소켓도 파일이에요</h2> <p>소켓은 프로세스 간 네트워크 I/O 엔드 포인트이다. 네트워크 통신의 양 끝단에 있는 것이 소켓이다. 프로세스 간 통신을 파일 I/O처럼 단일 인터페이스로 추상화 한것이 소켓의 시작이다. 그 덕분에 우리는 소켓을 open, write, read와 같은 I/O작업 처럼 사용할 수 있다. 이번 소켓 연결을 하면서 가장 신기한건 우리가 디스크를 읽는거와 소켓 통신을 하는게 차이가 없다는 것이다. 이것이 추상화의 힘인가 싶다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/file-meme-480.webp 480w,/assets/img/blog/file-meme-800.webp 800w,/assets/img/blog/file-meme-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/blog/file-meme.png" class="w-50" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption">결국은 다 파일이었어…!</figcaption> </figure> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">connfd</span> <span class="o">=</span> <span class="n">Accept</span><span class="p">(</span><span class="n">proxyfd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></div></div> <p>소켓 통신을 보면 파일 디스크럽터를 통해 입력을 받고 통신 또한 파일 디스크럽터를 통해 하는걸 볼 수 있다! 결국 모든게 다 파일인 것이다!<br/> 이러한 소켓 통신을 기반으로 우리가 아는 웹 HTTP는 어떻게 통신하는지 알아보자</p> <h2 id="http와-문자열-파싱">HTTP와 문자열 파싱</h2> <p>대부분의 통신은 소켓을 통해 이루어 진다. 그러면 HTTP통신은 어떻게 이루어지는지 알아보자! TCP같은 통신 규격도 있지만 나는 재밌게 보았던 문자열 파싱 중심으로 말해보려한다.</p> <p>우리가 naver같은 서버를 접속하면 어떤 원리로 사이트를 띄워줄까? 그것은 HTTP규격에 따라 통신을 하기에 가능한일이다.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GET</span> <span class="o">/</span> <span class="n">HTTP</span><span class="o">/</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span>
<span class="o">&lt;</span><span class="n">header</span><span class="p">...</span><span class="o">&gt;</span>
</code></pre></div></div> <p>우리가 HTTP요청을 보내면 서버는 위와같은 헤더를 받게된다. GET요청으로 <code class="language-plaintext highlighter-rouge">/</code> 이라는 데이터를 요구한다! HTTP통신 버전은 1.0이라는 소리이다. 그러면 이 요청에따라 서버는 응답하면 되는 것이다. 컴퓨터가 이러한 글을 읽을 수 있는 이유는 하나하나 파싱을 하기 때문이다.</p> <div class="img-pair"> <figure class="img-pair__item"> <img src="/assets/img/blog/chrom-parse.png" alt="크로니움 파싱 코드"/> <figcaption class="img-pair__caption">크로니움 파싱 코드</figcaption> </figure> <figure class="img-pair__item"> <img src="/assets/img/blog/tomcat-parse.png" alt="톰켓 서버 파싱 코드"/> <figcaption class="img-pair__caption">톰켓 서버 파싱 코드</figcaption> </figure> </div> <p>크로니움, 톰켓 서버 코드에도 문자열을 파싱하는 코드가 있는걸 볼 수 있다.<br/> 이렇게 헤더를 파싱하면 이후 작업은 간단하다 분기처리를 통해 클라이언트가 원하는 걸 주면된다 GET일때는 어떤걸 줄지, POST일때는, <code class="language-plaintext highlighter-rouge">/</code> 로 들어오면, <code class="language-plaintext highlighter-rouge">/abc.png</code> 같은 파일을 요청하면, 아니면 어떠한 실행파일의 결과를 요청하면! 이런걸 처리하여 클라이언트에게 주는 것이다.</p> <h2 id="컴퓨터는-글을-읽을-줄-모른다">컴퓨터는 글을 읽을 줄 모른다.</h2> <p>위에서 말했든 나는 다른 웹 프레임워크를 쓰며 어떻게 주소가 매핑되는지 관심이 없었다. 자석처럼 알아서 잘 매핑되는구나 생각했다. 하지만 직접 구현을 해보니 잘못된 생각이였음을 깨닳았다.</p> <p>결국 컴퓨터는 글을 읽을 줄 모르고 소켓으로 온 내용이 요청인지 아닌지도 구분하지 못한다. 우리가 통신을 하기 위해 규격을 세우고 그 내용대로 통신을 하기에 가능한 것이다. 규격대로 요청을 하고 규격대로 하나하나 파싱하고 분기 처리하여 결과를 돌려준다. 내부적인 코드를 보니 참 컴퓨터스럽다는 생각을 했다.</p>]]></content><author><name></name></author><category term="크래프톤"/><category term="정글"/><summary type="html"><![CDATA[세상은 문자열 파싱으로 돌아간다.]]></summary></entry><entry><title type="html">malloc lab - 삽질은 즐거워</title><link href="https://jeongns.github.io/blog/2025/malloc-lab-%EC%82%BD%EC%A7%88%EC%9D%80-%EC%A6%90%EA%B1%B0%EC%9B%8C/" rel="alternate" type="text/html" title="malloc lab - 삽질은 즐거워"/><published>2025-10-29T21:04:00+00:00</published><updated>2025-10-29T21:04:00+00:00</updated><id>https://jeongns.github.io/blog/2025/malloc%20lab%20-%20%EC%82%BD%EC%A7%88%EC%9D%80%20%EC%A6%90%EA%B1%B0%EC%9B%8C</id><content type="html" xml:base="https://jeongns.github.io/blog/2025/malloc-lab-%EC%82%BD%EC%A7%88%EC%9D%80-%EC%A6%90%EA%B1%B0%EC%9B%8C/"><![CDATA[<h2 id="malloc-lab">malloc lab</h2> <p>정글 7주차 malloc lab을 진행했다 직접 malloc, realloc, free를 구현하며 동적 메모리 할당에 대해 알아가는 시간이였다. 여러 시행착오가 있었지만 가장 기억이 남았던 디버깅 경험을 풀어보려 한다.</p> <h2 id="이게-왜-안됨">이게 왜 안됨?</h2> <p>코드를 짜다보면 분명 잘 짰는데 안되는 상황이 온다. malloc lab같은 경우 구현을 직접 해야하는 과제이다 보니 그러한 상황이 더 많이 나왔다.<br/> malloc lab은 특별한 변수들이 있는게 아니라 메모리에 직접 할당이 되기에 변수를 따라가며 디버깅 하기가 힘들었다. 그래서 안되면 코드를 훑어보고 AI에게 도움을 청하는 일이 많았다.<br/> 내 코드가 개성이 넘치는건지 내가 프롬포팅을 못하는건지 명시적 동적 메모리 할당을 구현하는데 유독 애를 먹었다. AI또한 무의미한 답변만 주고 도움이 되지 않았다.</p> <h2 id="삽질">삽질</h2> <p>결국 코드를 하나하나 따라가며 삽질을 하기로 했다. 변수가 아니라 메모리를 봐야하기 때문에 직접 메모리를 보며 코드진행에 따라 메모리가 정상적으로 할당되는지 보았다. 이렇게 메모리 하나씩 보니 설정했던 헤더, 푸터 등이 정상적으로 할당되는게 보이니 신기했다.</p> <p><img src="/assets/img/blog/malloc-memory.png" alt="사진과 같이 헤더, 푸터, 포인터 등이 정상적으로 할당이 되었는지 확인한다." class="w-50"/></p> <p>사진과 같이 헤더, 푸터, 포인터 등이 정상적으로 할당이 되었는지 확인한다.</p> <h2 id="원인결과">원인/결과</h2> <p><img src="/assets/img/blog/malloc-memory2.png" alt="image.png"/></p> <p>디버깅을 하다보니 메모리가 이상하게 움직이는 부분을 발견할 수 있었다!<br/> malloc을 진행하는데 footer부분의 값이 사라지는 것이다! 그렇기에 footer값을 못들고오고 병합과정에서 에러가 났던 것이였다.</p> <p>왜 값이 사라지는지 디버깅을 진행하자</p> <p><img src="/assets/img/blog/malloc-testcode.png" alt="image.png" class="w-50"/></p> <p>테스트 코드에서 실행 후 확보한 메모리에 특정한 값을 넣는다는 걸 알았다. 값을 넣으면서 나의 footer가 덮어 씌워진 것이다. 즉 내가 size조절을 못하여 footer가 덮어 씌워지는 상황이 발생한 것이였다.</p> <h2 id="바이브-디버깅">바이브 디버깅</h2> <p>이렇게 직접 디버깅을 하여 문제를 해결하니 여러 느낀점이 많았다. 해결하려고 AI한테 질문을 많이 했지만 고민만 잔뜩하고 제대로된 해결책은 안주고 결국 사람이 완벽히 이해하고 분석해야 한다는 것이다.</p> <p><img src="/assets/img/blog/바이브디버깅.png" alt="image.png"/></p> <p>물론 malloc lab을 하면서 AI에게 많은 도움을 받았다. 구현이나 디버깅을 하면서 모르는 부분을 잘 알려주고 예측하지 못한 부분의 문제를 잘 지적해 주기도 한다. 하지만 가끔 이런 상황이 오는 것 같다. 결국 사람이 코드를 이해 해야하는 것이다.</p> <p>오랜시간 삽질을 했지만 삽질한 시간은 나의 경험이 되는 것 같다. AI가 발전하며 AI를 잘 써야한다지만 역설적으로 이러한 <strong>삽질</strong>의 경험이 있는 개발자가 필요한거 아닐까 라는 생각도 든다.</p>]]></content><author><name></name></author><category term="크래프톤"/><category term="정글"/><summary type="html"><![CDATA[malloc lab]]></summary></entry><entry><title type="html">쉬지않는 CPU, Context Switching에 대하여</title><link href="https://jeongns.github.io/blog/2025/%EC%89%AC%EC%A7%80%EC%95%8A%EB%8A%94-CPU,-Context-Switching%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/" rel="alternate" type="text/html" title="쉬지않는 CPU, Context Switching에 대하여"/><published>2025-10-23T14:25:00+00:00</published><updated>2025-10-23T14:25:00+00:00</updated><id>https://jeongns.github.io/blog/2025/%EC%89%AC%EC%A7%80%EC%95%8A%EB%8A%94%20CPU,%20Context%20Switching%EC%97%90%20%EB%8C%80%ED%95%98%EC%97%AC</id><content type="html" xml:base="https://jeongns.github.io/blog/2025/%EC%89%AC%EC%A7%80%EC%95%8A%EB%8A%94-CPU,-Context-Switching%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/"><![CDATA[<h2 id="cpu가-불쌍해-보여요">CPU가 불쌍해 보여요</h2> <p>CS를 공부하다보니 CPU에게 일을 시키게 하기 위해 많은 기술이 들어가는걸 알게 되었다. 정말 쉬지않게 만들기 위해 다양한 방법을 사용한다는 것을 알았다. 이러한 모습이 노예보다 못한 것 같아 불쌍하다는 생각도 들었다. 오늘은 CPU를 굴리는 방법 중 하나인 Context Switching에 대해 알아보려고 한다.</p> <h2 id="context-switching이란">Context Switching이란?</h2> <p><strong>Context switching</strong>이란 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전에 프로세스의 상태(Context)를 보관하고 새로운 프로세스의 상태를 적재하는 작업을 말한다.</p> <p>Context에는 프로세스를 실행 하기 위한 실행 상태 정보가 담겨있다. 커널은 context swithc를 위해 CPU의 상태 정보를 PCB(Process Control Block)에 담는다.</p> <p>(Ubuntu 24.04.3 LTS) 기준 pahole을 사용하여 현재 구현된 Linux PCB 구현체를 확인할 수 있다. 아래는 linux에서 사용하는 PCB에 구현체 task_struct의 일부 모습이다.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">task_struct</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">thread_info</span>         <span class="n">thread_info</span><span class="p">;</span>          <span class="cm">/*     0    24 */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>               <span class="n">__state</span><span class="p">;</span>              <span class="cm">/*    24     4 */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>               <span class="n">saved_state</span><span class="p">;</span>          <span class="cm">/*    28     4 */</span>
    <span class="kt">void</span> <span class="o">*</span>                     <span class="n">stack</span><span class="p">;</span>                <span class="cm">/*    32     8 */</span>
    <span class="n">refcount_t</span>                 <span class="n">usage</span><span class="p">;</span>                <span class="cm">/*    40     4 */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>               <span class="n">flags</span><span class="p">;</span>                <span class="cm">/*    44     4 */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>               <span class="n">ptrace</span><span class="p">;</span>               <span class="cm">/*    48     4 */</span>
    <span class="kt">int</span>                        <span class="n">on_cpu</span><span class="p">;</span>               <span class="cm">/*    52     4 */</span>
    <span class="k">struct</span> <span class="n">__call_single_node</span>  <span class="n">wake_entry</span><span class="p">;</span>           <span class="cm">/*    56    16 */</span>
    <span class="cm">/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>               <span class="n">wakee_flips</span><span class="p">;</span>          <span class="cm">/*    72     4 */</span>

    <span class="p">...</span><span class="err">중략</span><span class="p">...</span>    

    <span class="cm">/* size: 13888, cachelines: 217, members: 262 */</span>
    <span class="cm">/* sum members: 13753, holes: 17, sum holes: 119 */</span>
    <span class="cm">/* sum bitfield members: 82 bits, bit holes: 2, sum bit holes: 46 bits */</span>
    <span class="cm">/* paddings: 6, sum paddings: 49 */</span>
    <span class="cm">/* forced alignments: 2, forced holes: 2, sum forced holes: 64 */</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="필요성">필요성</h3> <p>프로세스의 동시성을 유지하기 위해 꼭 필요한 기법이다. CPU의 코어는 한번에 하나의 프로세스만 실행할 수 있으므로 여러 프로세스를 빠르게 교체 실행 하여 동시의 동작하는 것처럼 만든다</p> <h3 id="종류">종류</h3> <p>Context switching는 크게 두가지 상황에서 이뤄난다.</p> <ul> <li><strong>자발적 스위칭 (Voluntary Context Switch)</strong>: 프로세스가 I/O요청이나 sleep()등으로 스스로 대기상태에 들어가 CPU가 유휴 상태가 발생될 떄</li> <li><strong>강제적 스위칭 (Involuntary Context Switch)</strong>: 스케줄러 정책에 따라 CPU 점유 시간이 끝났거나 더 높은 우선순위의 프로세스가 준비 되었을 때</li> </ul> <p>자발적 스위칭만 존재한다면 하나의 프로세스가 CPU를 점유할 수 있다. 프로세스의 동시성이 깨지는 것이다. 그렇기에 일정한 정책에 따라 강제적 스위칭을 해준다.</p> <h3 id="비용">비용</h3> <p>스위칭은 무거운 작업이다. 단순히 실행 상태를 저장하고 복원하는 오버헤드뿐 아니라 TLB flush를 해야하고 CPU 캐시를 다시 적재해야하기 때문이다.</p> <h3 id="과정">과정</h3> <p>context switching은 단순하게 지금 상태를 PCB에 저장하고 다음 프로세스가 PCB에서 상태를 가져오는 작업이다. 우리는 조금 더 깊히 리눅스 소스 코드를 보며 어떻게 Context switching이 이뤄지는지 알아보자.</p> <p>리눅스 context_switch()</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">__always_inline</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span>
<span class="nf">context_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
            <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">prepare_task_switch</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

    <span class="cm">/*
        * For paravirt, this is coupled with an exit in switch_to to
        * combine the page table reload and the switch backend into
        * one hypercall.
        */</span>
    <span class="n">arch_start_context_switch</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>

    <span class="cm">/*
        * kernel -&gt; kernel   lazy + transfer active
        *   user -&gt; kernel   lazy + mmgrab_lazy_tlb() active
        *
        * kernel -&gt;   user   switch + mmdrop_lazy_tlb() active
        *   user -&gt;   user   switch
        *
        * switch_mm_cid() needs to be updated if the barriers provided
        * by context_switch() are modified.
        */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>                                <span class="c1">// to kernel</span>
        <span class="n">enter_lazy_tlb</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

        <span class="n">next</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>                           <span class="c1">// from user</span>
            <span class="n">mmgrab_lazy_tlb</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                                        <span class="c1">// to user</span>
        <span class="n">membarrier_switch_mm</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
        <span class="cm">/*
            * sys_membarrier() requires an smp_mb() between setting
            * rq-&gt;curr / membarrier_switch_mm() and returning to userspace.
            *
            * The below provides this either through switch_mm(), or in
            * case 'prev-&gt;active_mm == next-&gt;mm' through
            * finish_task_switch()'s mmdrop().
            */</span>
        <span class="n">switch_mm_irqs_off</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="n">lru_gen_use_mm</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>                        <span class="c1">// from kernel</span>
            <span class="cm">/* will mmdrop_lazy_tlb() in finish_task_switch(). */</span>
            <span class="n">rq</span><span class="o">-&gt;</span><span class="n">prev_mm</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">;</span>
            <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* switch_mm_cid() requires the memory barriers above. */</span>
    <span class="n">switch_mm_cid</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

    <span class="n">prepare_lock_switch</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>

    <span class="cm">/* Here we just switch the register state and the stack. */</span>
    <span class="n">switch_to</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
    <span class="n">barrier</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">finish_task_switch</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>소스 코드를 보면 위와 같은 분기가 나뉘어 진것을 볼 수 있다.</p> <ul> <li>커널 스레드 → 유저 스레드</li> <li>커널스레드 → 커널 스레드</li> <li>유저 스레드 → 커널 스레드</li> <li>유저 스레드 → 유저 스레드</li> </ul> <p>이렇게 나뉘는 이유는 커널 스레드가 VM을 가지고 있지 않기 때문이다.<br/> 커널 쓰레드는 VM을 가질 필요가 없어 잠깐 빌려쓴다 그 덕분에 스위칭시 TLB flush를 해야하지만 같은 VM을 바라보는 스레드와 스위칭을 한다면 TLB flush를 안해도 되는 이점을 얻게된다!</p> <p>커널 내부 처리를 하는 내부 스레드는 담을 정보가 없기 때문에 VM을 지니지 않고 그 전 스레드의 가상주소를 바라보게된다 <code class="language-plaintext highlighter-rouge">next-&gt;active_mm = prev-&gt;active_mm;</code> 코드상에서는 해당 부분이 그러한 부분이다. 커널이 참조하는 VM이 사라져도 안되기때문에 커널 스레드 처리를 위해 다양한 분기를 처리한다.</p> <h2 id="참고자료">참고자료</h2> <ul> <li><a href="https://ko.wikipedia.org/wiki/%EB%AC%B8%EB%A7%A5_%EA%B5%90%ED%99%98">https://ko.wikipedia.org/wiki/문맥_교환</a></li> <li><a href="https://linux-kernel-labs.github.io/refs/heads/master/lectures/processes.html">https://linux-kernel-labs.github.io/refs/heads/master/lectures/processes.html</a></li> </ul>]]></content><author><name></name></author><category term="크래프톤"/><category term="정글"/><summary type="html"><![CDATA[CPU가 불쌍해 보여요 CS를 공부하다보니 CPU에게 일을 시키게 하기 위해 많은 기술이 들어가는걸 알게 되었다. 정말 쉬지않게 만들기 위해 다양한 방법을 사용한다는 것을 알았다. 이러한 모습이 노예보다 못한 것 같아 불쌍하다는 생각도 들었다. 오늘은 CPU를 굴리는 방법 중 하나인 Context Switching에 대해 알아보려고 한다.]]></summary></entry><entry><title type="html">미니 프로젝트 회고록</title><link href="https://jeongns.github.io/blog/2025/%EB%AF%B8%EB%8B%88-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%9A%8C%EA%B3%A0%EB%A1%9D/" rel="alternate" type="text/html" title="미니 프로젝트 회고록"/><published>2025-09-04T18:45:00+00:00</published><updated>2025-09-04T18:45:00+00:00</updated><id>https://jeongns.github.io/blog/2025/%EB%AF%B8%EB%8B%88%20%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%20%ED%9A%8C%EA%B3%A0%EB%A1%9D</id><content type="html" xml:base="https://jeongns.github.io/blog/2025/%EB%AF%B8%EB%8B%88-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%9A%8C%EA%B3%A0%EB%A1%9D/"><![CDATA[<p>9월 1일 정글 입성과 함께 시작된 미니 프로젝트가 드디어 끝났다. 정글들어오자마자 바로 팀이 구성되며 정신없이 시작된 미니 프로젝트였다.</p> <p>갑자기 빠르게 개발을 진행해야 하다 보니 개발적인 부분보다는 어떻게 팀원들과 수월하게 개발할 수 있을까 고민했고 그부분에서 큰 역할을 한것은 노션인 것 같다.</p> <p><img src="/assets/img/blog/api.png" alt="alt text"/></p> <p>깔끔하지는 않지만 팀원들과 공유를 해야하는 자료를 공유하며 진행을 하니 진행이 수월했다.</p> <p>가장 잘썼다고 생각하는 부분이 api를 정의하는 것이였다. 기존 노션에 공유되어있는 좋은 템플릿을 바탕으로 상세하지 않지만 API의 변수명 정도를 서로 정의를 하고 시작하니 개발하면서 막히는 부분이 없었다. 프론트부분을 개발하는 나는 명세서를 믿고 개발하고 백엔드를 개발하는 분들도 명세서를 믿고 개발을 하니 따로 맞출 필요 없이 결과물이 잘 나왔다.</p> <p>Ai툴을 많이 사용하여 코드가 난잡하지만 서로 협업을 하여 기능을 깔끔하게 구현해서 만족스럽다.</p> <p>앞으로도 팀 단위로 진행을 하는데 수월하게 진행 할 수 있도록 공부와 노력을 해야겠다.</p> <p>-우리 팀원과 함께만든 TIL 기록 플렛폼 ‘정글북’이다. <br/> <a href="https://github.com/edward-official/junglebook">https://github.com/edward-official/junglebook</a></p>]]></content><author><name></name></author><category term="크래프톤"/><category term="정글"/><summary type="html"><![CDATA[9월 1일 정글 입성과 함께 시작된 미니 프로젝트가 드디어 끝났다. 정글들어오자마자 바로 팀이 구성되며 정신없이 시작된 미니 프로젝트였다.]]></summary></entry></feed>